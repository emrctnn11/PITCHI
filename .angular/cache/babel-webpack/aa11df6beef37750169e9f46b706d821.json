{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid, setItemAsync, removeItemAsync, getItemSynchronously, getItemAsync } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY, EXPIRY_MARGIN, NETWORK_FAILURE } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.currentUser = null;\n    this.currentSession = null;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.multiTab = settings.multiTab;\n    this.localStorage = settings.localStorage || globalThis.localStorage;\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch\n    });\n\n    this._recoverSession();\n\n    this._recoverAndRefresh();\n\n    this._listenForMultiTabEvents();\n\n    this._handleVisibilityChange();\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({\n        storeSession: true\n      }).then(({\n        error\n      }) => {\n        if (error) {\n          console.error('Error getting session from URL.', error);\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n   * @param data Optional user metadata.\n   */\n\n\n  signUp({\n    email,\n    password,\n    phone\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = phone && password ? yield this.api.signUpWithPhone(phone, password, {\n          data: options.data,\n          captchaToken: options.captchaToken\n        }) : yield this.api.signUpWithEmail(email, password, {\n          redirectTo: options.redirectTo,\n          data: options.data,\n          captchaToken: options.captchaToken\n        });\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on sign up.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n\n\n  signIn({\n    email,\n    phone,\n    password,\n    refreshToken,\n    provider,\n    oidc\n  }, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        if (email && !password) {\n          const {\n            error\n          } = yield this.api.sendMagicLinkEmail(email, {\n            redirectTo: options.redirectTo,\n            shouldCreateUser: options.shouldCreateUser,\n            captchaToken: options.captchaToken\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (email && password) {\n          return this._handleEmailSignIn(email, password, {\n            redirectTo: options.redirectTo\n          });\n        }\n\n        if (phone && !password) {\n          const {\n            error\n          } = yield this.api.sendMobileOTP(phone, {\n            shouldCreateUser: options.shouldCreateUser,\n            captchaToken: options.captchaToken\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n\n        if (phone && password) {\n          return this._handlePhoneSignIn(phone, password);\n        }\n\n        if (refreshToken) {\n          // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n          const {\n            error\n          } = yield this._callRefreshToken(refreshToken);\n          if (error) throw error;\n          return {\n            user: this.currentUser,\n            session: this.currentSession,\n            error: null\n          };\n        }\n\n        if (provider) {\n          return this._handleProviderSignIn(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes\n          });\n        }\n\n        if (oidc) {\n          return this._handleOpenIDConnectSignIn(oidc);\n        }\n\n        throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param type The user's verification type.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n\n\n  verifyOTP(params, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n\n        const {\n          data,\n          error\n        } = yield this.api.verifyOTP(params, options);\n\n        if (error) {\n          throw error;\n        }\n\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n\n        let session = null;\n        let user = null;\n\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n\n          this._saveSession(session);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        if (data.id) {\n          user = data;\n        }\n\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n\n\n  user() {\n    return this.currentUser;\n  }\n  /**\n   * Returns the session data, if there is an active session.\n   */\n\n\n  session() {\n    return this.currentSession;\n  }\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n\n\n  refreshSession() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.'); // currentSession and currentUser will be updated to latest on _callRefreshToken\n\n        const {\n          error\n        } = yield this._callRefreshToken();\n        if (error) throw error;\n        return {\n          data: this.currentSession,\n          user: this.currentUser,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n\n\n  update(attributes) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.');\n        const {\n          user,\n          error\n        } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n        if (error) throw error;\n        if (!user) throw Error('Invalid user data.');\n        const session = Object.assign(Object.assign({}, this.currentSession), {\n          user\n        });\n\n        this._saveSession(session);\n\n        this._notifyAllSubscribers('USER_UPDATED');\n\n        return {\n          data: user,\n          user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n\n\n  setSession(refresh_token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n\n        if (error) {\n          return {\n            session: null,\n            error: error\n          };\n        }\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e,\n          session: null\n        };\n      }\n    });\n  }\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n\n\n  setAuth(access_token) {\n    this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n      access_token,\n      token_type: 'bearer',\n      user: this.user()\n    });\n\n    this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n    return this.currentSession;\n  }\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n\n\n  getSessionFromUrl(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new Error('No browser detected.');\n        const error_description = getParameterByName('error_description');\n        if (error_description) throw new Error(error_description);\n        const provider_token = getParameterByName('provider_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new Error('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new Error('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new Error('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new Error('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          user,\n          error\n        } = yield this.api.getUser(access_token);\n        if (error) throw error;\n        const session = {\n          provider_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user: user\n        };\n\n        if (options === null || options === void 0 ? void 0 : options.storeSession) {\n          this._saveSession(session);\n\n          const recoveryMode = getParameterByName('type');\n\n          this._notifyAllSubscribers('SIGNED_IN');\n\n          if (recoveryMode === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY');\n          }\n        } // Remove tokens from URL\n\n\n        window.location.hash = '';\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n   */\n\n\n  signOut() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n\n      this._removeSession();\n\n      this._notifyAllSubscribers('SIGNED_OUT');\n\n      if (accessToken) {\n        const {\n          error\n        } = yield this.api.signOut(accessToken);\n        if (error) return {\n          error\n        };\n      }\n\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n\n\n  onAuthStateChange(callback) {\n    try {\n      const id = uuid();\n      const subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      return {\n        data: subscription,\n        error: null\n      };\n    } catch (e) {\n      return {\n        data: null,\n        error: e\n      };\n    }\n  }\n\n  _handleEmailSignIn(email, password, options = {}) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithEmail(email, password, {\n          redirectTo: options.redirectTo\n        });\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handlePhoneSignIn(phone, password) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithPhone(phone, password);\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n\n        if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _handleProviderSignIn(provider, options = {}) {\n    const url = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes\n    });\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url;\n      }\n\n      return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n      return {\n        data: null,\n        user: null,\n        session: null,\n        error: e\n      };\n    }\n  }\n\n  _handleOpenIDConnectSignIn({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (id_token && nonce && (client_id && issuer || provider)) {\n        try {\n          const {\n            data,\n            error\n          } = yield this.api.signInWithOpenIDConnect({\n            id_token,\n            nonce,\n            client_id,\n            issuer,\n            provider\n          });\n          if (error || !data) return {\n            user: null,\n            session: null,\n            error\n          };\n\n          this._saveSession(data);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n\n          return {\n            user: data.user,\n            session: data,\n            error: null\n          };\n        } catch (e) {\n          return {\n            user: null,\n            session: null,\n            error: e\n          };\n        }\n      }\n\n      throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n    });\n  }\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n\n\n  _recoverSession() {\n    try {\n      const data = getItemSynchronously(this.localStorage, STORAGE_KEY);\n      if (!data) return null;\n      const {\n        currentSession,\n        expiresAt\n      } = data;\n      const timeNow = Math.round(Date.now() / 1000);\n\n      if (expiresAt >= timeNow + EXPIRY_MARGIN && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n        this._saveSession(currentSession);\n\n        this._notifyAllSubscribers('SIGNED_IN');\n      }\n    } catch (error) {\n      console.log('error', error);\n    }\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n\n\n  _recoverAndRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield getItemAsync(this.localStorage, STORAGE_KEY);\n        if (!data) return null;\n        const {\n          currentSession,\n          expiresAt\n        } = data;\n        const timeNow = Math.round(Date.now() / 1000);\n\n        if (expiresAt < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            this.networkRetries++;\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n\n            if (error) {\n              console.log(error.message);\n\n              if (error.message === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return;\n              }\n\n              yield this._removeSession();\n            }\n\n            this.networkRetries = 0;\n          } else {\n            this._removeSession();\n          }\n        } else if (!currentSession) {\n          console.log('Current session is missing data.');\n\n          this._removeSession();\n        } else {\n          // should be handled on _recoverSession method already\n          // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n          this._saveSession(currentSession);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n      } catch (err) {\n        console.error(err);\n        return null;\n      }\n    });\n  }\n\n  _callRefreshToken(refresh_token) {\n    var _a;\n\n    if (refresh_token === void 0) {\n      refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n        if (error) throw error;\n        if (!data) throw Error('Invalid session data.');\n\n        this._saveSession(data);\n\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n        this._notifyAllSubscribers('SIGNED_IN');\n\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n\n  _notifyAllSubscribers(event) {\n    this.stateChangeEmitters.forEach(x => x.callback(event, this.currentSession));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n\n\n  _saveSession(session) {\n    this.currentSession = session;\n    this.currentUser = session.user;\n    const expiresAt = session.expires_at;\n\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000);\n      const expiresIn = expiresAt - timeNow;\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n    } // Do we need any extra check before persist session\n    // access_token or user ?\n\n\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession);\n    }\n  }\n\n  _persistSession(currentSession) {\n    const data = {\n      currentSession,\n      expiresAt: currentSession.expires_at\n    };\n    setItemAsync(this.localStorage, STORAGE_KEY, data);\n  }\n\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.currentSession = null;\n      this.currentUser = null;\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      removeItemAsync(this.localStorage, STORAGE_KEY);\n    });\n  }\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n\n\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken) return;\n    this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n      this.networkRetries++;\n      const {\n        error\n      } = yield this._callRefreshToken();\n      if (!error) this.networkRetries = 0;\n      if ((error === null || error === void 0 ? void 0 : error.message) === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n    }), value);\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n  }\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n\n\n  _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('storage', e => {\n        var _a;\n\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue));\n\n          if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n            this._saveSession(newSession.currentSession);\n\n            this._notifyAllSubscribers('SIGNED_IN');\n          } else {\n            this._removeSession();\n\n            this._notifyAllSubscribers('SIGNED_OUT');\n          }\n        }\n      });\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error);\n    }\n  }\n\n  _handleVisibilityChange() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n          this._recoverAndRefresh();\n        }\n      });\n    } catch (error) {\n      console.error('_handleVisibilityChange', error);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/90545/Documents/GitHub/PITCHI/node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","GoTrueApi","isBrowser","getParameterByName","uuid","setItemAsync","removeItemAsync","getItemSynchronously","getItemAsync","GOTRUE_URL","DEFAULT_HEADERS","STORAGE_KEY","EXPIRY_MARGIN","NETWORK_FAILURE","polyfillGlobalThis","DEFAULT_OPTIONS","url","autoRefreshToken","persistSession","detectSessionInUrl","multiTab","headers","GoTrueClient","constructor","options","stateChangeEmitters","Map","networkRetries","settings","Object","assign","currentUser","currentSession","localStorage","globalThis","api","cookieOptions","fetch","_recoverSession","_recoverAndRefresh","_listenForMultiTabEvents","_handleVisibilityChange","getSessionFromUrl","storeSession","error","console","signUp","email","password","phone","_removeSession","data","signUpWithPhone","captchaToken","signUpWithEmail","redirectTo","session","user","access_token","_saveSession","_notifyAllSubscribers","id","signIn","refreshToken","provider","oidc","sendMagicLinkEmail","shouldCreateUser","_handleEmailSignIn","sendMobileOTP","_handlePhoneSignIn","_callRefreshToken","_handleProviderSignIn","scopes","_handleOpenIDConnectSignIn","Error","verifyOTP","params","refreshSession","_a","update","attributes","updateUser","setSession","refresh_token","refreshAccessToken","setAuth","token_type","error_description","provider_token","expires_in","timeNow","Math","round","Date","now","expires_at","parseInt","getUser","recoveryMode","window","location","hash","signOut","accessToken","onAuthStateChange","callback","subscription","unsubscribe","delete","set","_b","signInWithEmail","confirmed_at","email_confirmed_at","signInWithPhone","phone_confirmed_at","getUrlForProvider","href","id_token","nonce","client_id","issuer","signInWithOpenIDConnect","expiresAt","log","message","ERROR_MESSAGE","MAX_RETRIES","refreshTokenTimer","clearTimeout","setTimeout","pow","RETRY_INTERVAL","err","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","unref","addEventListener","key","newSession","JSON","parse","String","newValue","document","visibilityState"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,WAASC,KAAT,CAAeC,KAAf,EAAsB;AAAE,WAAOA,KAAK,YAAYH,CAAjB,GAAqBG,KAArB,GAA6B,IAAIH,CAAJ,CAAM,UAAUI,OAAV,EAAmB;AAAEA,MAAAA,OAAO,CAACD,KAAD,CAAP;AAAiB,KAA5C,CAApC;AAAoF;;AAC5G,SAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAT,CAAN,EAAyB,UAAUD,OAAV,EAAmBE,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBJ,KAAnB,EAA0B;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAACQ,IAAV,CAAeN,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBR,KAAlB,EAAyB;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAAC,OAAD,CAAT,CAAmBE,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACT,KAAR,CAArB,GAAsCD,KAAK,CAACU,MAAM,CAACT,KAAR,CAAL,CAAoBW,IAApB,CAAyBP,SAAzB,EAAoCI,QAApC,CAAtC;AAAsF;;AAC9GH,IAAAA,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAV,CAAgBjB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDU,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CARD;;AASA,OAAOO,SAAP,MAAsB,aAAtB;AACA,SAASC,SAAT,EAAoBC,kBAApB,EAAwCC,IAAxC,EAA8CC,YAA9C,EAA4DC,eAA5D,EAA6EC,oBAA7E,EAAmGC,YAAnG,QAAwH,eAAxH;AACA,SAASC,UAAT,EAAqBC,eAArB,EAAsCC,WAAtC,EAAmDC,aAAnD,EAAkEC,eAAlE,QAA0F,iBAA1F;AACA,SAASC,kBAAT,QAAmC,iBAAnC;AACAA,kBAAkB,G,CAAI;;AACtB,MAAMC,eAAe,GAAG;AACpBC,EAAAA,GAAG,EAAEP,UADe;AAEpBQ,EAAAA,gBAAgB,EAAE,IAFE;AAGpBC,EAAAA,cAAc,EAAE,IAHI;AAIpBC,EAAAA,kBAAkB,EAAE,IAJA;AAKpBC,EAAAA,QAAQ,EAAE,IALU;AAMpBC,EAAAA,OAAO,EAAEX;AANW,CAAxB;AAQA,eAAe,MAAMY,YAAN,CAAmB;AAC9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,SAAKC,mBAAL,GAA2B,IAAIC,GAAJ,EAA3B;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,UAAMC,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBf,eAAlB,CAAd,EAAkDS,OAAlD,CAAjB;AACA,SAAKO,WAAL,GAAmB,IAAnB;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA,SAAKf,gBAAL,GAAwBW,QAAQ,CAACX,gBAAjC;AACA,SAAKC,cAAL,GAAsBU,QAAQ,CAACV,cAA/B;AACA,SAAKE,QAAL,GAAgBQ,QAAQ,CAACR,QAAzB;AACA,SAAKa,YAAL,GAAoBL,QAAQ,CAACK,YAAT,IAAyBC,UAAU,CAACD,YAAxD;AACA,SAAKE,GAAL,GAAW,IAAIlC,SAAJ,CAAc;AACrBe,MAAAA,GAAG,EAAEY,QAAQ,CAACZ,GADO;AAErBK,MAAAA,OAAO,EAAEO,QAAQ,CAACP,OAFG;AAGrBe,MAAAA,aAAa,EAAER,QAAQ,CAACQ,aAHH;AAIrBC,MAAAA,KAAK,EAAET,QAAQ,CAACS;AAJK,KAAd,CAAX;;AAMA,SAAKC,eAAL;;AACA,SAAKC,kBAAL;;AACA,SAAKC,wBAAL;;AACA,SAAKC,uBAAL;;AACA,QAAIb,QAAQ,CAACT,kBAAT,IAA+BjB,SAAS,EAAxC,IAA8C,CAAC,CAACC,kBAAkB,CAAC,cAAD,CAAtE,EAAwF;AACpF;AACA,WAAKuC,iBAAL,CAAuB;AAAEC,QAAAA,YAAY,EAAE;AAAhB,OAAvB,EAA+C5C,IAA/C,CAAoD,CAAC;AAAE6C,QAAAA;AAAF,OAAD,KAAe;AAC/D,YAAIA,KAAJ,EAAW;AACPC,UAAAA,OAAO,CAACD,KAAR,CAAc,iCAAd,EAAiDA,KAAjD;AACH;AACJ,OAJD;AAKH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIE,EAAAA,MAAM,CAAC;AAAEC,IAAAA,KAAF;AAASC,IAAAA,QAAT;AAAmBC,IAAAA;AAAnB,GAAD,EAA6BzB,OAAO,GAAG,EAAvC,EAA2C;AAC7C,WAAO1C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,aAAKoE,cAAL;;AACA,cAAM;AAAEC,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkBK,KAAK,IAAID,QAAT,GAClB,MAAM,KAAKb,GAAL,CAASiB,eAAT,CAAyBH,KAAzB,EAAgCD,QAAhC,EAA0C;AAC9CG,UAAAA,IAAI,EAAE3B,OAAO,CAAC2B,IADgC;AAE9CE,UAAAA,YAAY,EAAE7B,OAAO,CAAC6B;AAFwB,SAA1C,CADY,GAKlB,MAAM,KAAKlB,GAAL,CAASmB,eAAT,CAAyBP,KAAzB,EAAgCC,QAAhC,EAA0C;AAC9CO,UAAAA,UAAU,EAAE/B,OAAO,CAAC+B,UAD0B;AAE9CJ,UAAAA,IAAI,EAAE3B,OAAO,CAAC2B,IAFgC;AAG9CE,UAAAA,YAAY,EAAE7B,OAAO,CAAC6B;AAHwB,SAA1C,CALZ;;AAUA,YAAIT,KAAJ,EAAW;AACP,gBAAMA,KAAN;AACH;;AACD,YAAI,CAACO,IAAL,EAAW;AACP,gBAAM,+BAAN;AACH;;AACD,YAAIK,OAAO,GAAG,IAAd;AACA,YAAIC,IAAI,GAAG,IAAX;;AACA,YAAIN,IAAI,CAACO,YAAT,EAAuB;AACnBF,UAAAA,OAAO,GAAGL,IAAV;AACAM,UAAAA,IAAI,GAAGD,OAAO,CAACC,IAAf;;AACA,eAAKE,YAAL,CAAkBH,OAAlB;;AACA,eAAKI,qBAAL,CAA2B,WAA3B;AACH;;AACD,YAAIT,IAAI,CAACU,EAAT,EAAa;AACTJ,UAAAA,IAAI,GAAGN,IAAP;AACH;;AACD,eAAO;AAAEM,UAAAA,IAAF;AAAQD,UAAAA,OAAR;AAAiBZ,UAAAA,KAAK,EAAE;AAAxB,SAAP;AACH,OA9BD,CA+BA,OAAOjD,CAAP,EAAU;AACN,eAAO;AAAE8D,UAAAA,IAAI,EAAE,IAAR;AAAcD,UAAAA,OAAO,EAAE,IAAvB;AAA6BZ,UAAAA,KAAK,EAAEjD;AAApC,SAAP;AACH;AACJ,KAnCe,CAAhB;AAoCH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACImE,EAAAA,MAAM,CAAC;AAAEf,IAAAA,KAAF;AAASE,IAAAA,KAAT;AAAgBD,IAAAA,QAAhB;AAA0Be,IAAAA,YAA1B;AAAwCC,IAAAA,QAAxC;AAAkDC,IAAAA;AAAlD,GAAD,EAA2DzC,OAAO,GAAG,EAArE,EAAyE;AAC3E,WAAO1C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,aAAKoE,cAAL;;AACA,YAAIH,KAAK,IAAI,CAACC,QAAd,EAAwB;AACpB,gBAAM;AAAEJ,YAAAA;AAAF,cAAY,MAAM,KAAKT,GAAL,CAAS+B,kBAAT,CAA4BnB,KAA5B,EAAmC;AACvDQ,YAAAA,UAAU,EAAE/B,OAAO,CAAC+B,UADmC;AAEvDY,YAAAA,gBAAgB,EAAE3C,OAAO,CAAC2C,gBAF6B;AAGvDd,YAAAA,YAAY,EAAE7B,OAAO,CAAC6B;AAHiC,WAAnC,CAAxB;AAKA,iBAAO;AAAEI,YAAAA,IAAI,EAAE,IAAR;AAAcD,YAAAA,OAAO,EAAE,IAAvB;AAA6BZ,YAAAA;AAA7B,WAAP;AACH;;AACD,YAAIG,KAAK,IAAIC,QAAb,EAAuB;AACnB,iBAAO,KAAKoB,kBAAL,CAAwBrB,KAAxB,EAA+BC,QAA/B,EAAyC;AAC5CO,YAAAA,UAAU,EAAE/B,OAAO,CAAC+B;AADwB,WAAzC,CAAP;AAGH;;AACD,YAAIN,KAAK,IAAI,CAACD,QAAd,EAAwB;AACpB,gBAAM;AAAEJ,YAAAA;AAAF,cAAY,MAAM,KAAKT,GAAL,CAASkC,aAAT,CAAuBpB,KAAvB,EAA8B;AAClDkB,YAAAA,gBAAgB,EAAE3C,OAAO,CAAC2C,gBADwB;AAElDd,YAAAA,YAAY,EAAE7B,OAAO,CAAC6B;AAF4B,WAA9B,CAAxB;AAIA,iBAAO;AAAEI,YAAAA,IAAI,EAAE,IAAR;AAAcD,YAAAA,OAAO,EAAE,IAAvB;AAA6BZ,YAAAA;AAA7B,WAAP;AACH;;AACD,YAAIK,KAAK,IAAID,QAAb,EAAuB;AACnB,iBAAO,KAAKsB,kBAAL,CAAwBrB,KAAxB,EAA+BD,QAA/B,CAAP;AACH;;AACD,YAAIe,YAAJ,EAAkB;AACd;AACA,gBAAM;AAAEnB,YAAAA;AAAF,cAAY,MAAM,KAAK2B,iBAAL,CAAuBR,YAAvB,CAAxB;AACA,cAAInB,KAAJ,EACI,MAAMA,KAAN;AACJ,iBAAO;AACHa,YAAAA,IAAI,EAAE,KAAK1B,WADR;AAEHyB,YAAAA,OAAO,EAAE,KAAKxB,cAFX;AAGHY,YAAAA,KAAK,EAAE;AAHJ,WAAP;AAKH;;AACD,YAAIoB,QAAJ,EAAc;AACV,iBAAO,KAAKQ,qBAAL,CAA2BR,QAA3B,EAAqC;AACxCT,YAAAA,UAAU,EAAE/B,OAAO,CAAC+B,UADoB;AAExCkB,YAAAA,MAAM,EAAEjD,OAAO,CAACiD;AAFwB,WAArC,CAAP;AAIH;;AACD,YAAIR,IAAJ,EAAU;AACN,iBAAO,KAAKS,0BAAL,CAAgCT,IAAhC,CAAP;AACH;;AACD,cAAM,IAAIU,KAAJ,CAAW,2FAAX,CAAN;AACH,OA9CD,CA+CA,OAAOhF,CAAP,EAAU;AACN,eAAO;AAAE8D,UAAAA,IAAI,EAAE,IAAR;AAAcD,UAAAA,OAAO,EAAE,IAAvB;AAA6BZ,UAAAA,KAAK,EAAEjD;AAApC,SAAP;AACH;AACJ,KAnDe,CAAhB;AAoDH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIiF,EAAAA,SAAS,CAACC,MAAD,EAASrD,OAAO,GAAG,EAAnB,EAAuB;AAC5B,WAAO1C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,aAAKoE,cAAL;;AACA,cAAM;AAAEC,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKT,GAAL,CAASyC,SAAT,CAAmBC,MAAnB,EAA2BrD,OAA3B,CAA9B;;AACA,YAAIoB,KAAJ,EAAW;AACP,gBAAMA,KAAN;AACH;;AACD,YAAI,CAACO,IAAL,EAAW;AACP,gBAAM,0CAAN;AACH;;AACD,YAAIK,OAAO,GAAG,IAAd;AACA,YAAIC,IAAI,GAAG,IAAX;;AACA,YAAIN,IAAI,CAACO,YAAT,EAAuB;AACnBF,UAAAA,OAAO,GAAGL,IAAV;AACAM,UAAAA,IAAI,GAAGD,OAAO,CAACC,IAAf;;AACA,eAAKE,YAAL,CAAkBH,OAAlB;;AACA,eAAKI,qBAAL,CAA2B,WAA3B;AACH;;AACD,YAAIT,IAAI,CAACU,EAAT,EAAa;AACTJ,UAAAA,IAAI,GAAGN,IAAP;AACH;;AACD,eAAO;AAAEM,UAAAA,IAAF;AAAQD,UAAAA,OAAR;AAAiBZ,UAAAA,KAAK,EAAE;AAAxB,SAAP;AACH,OArBD,CAsBA,OAAOjD,CAAP,EAAU;AACN,eAAO;AAAE8D,UAAAA,IAAI,EAAE,IAAR;AAAcD,UAAAA,OAAO,EAAE,IAAvB;AAA6BZ,UAAAA,KAAK,EAAEjD;AAApC,SAAP;AACH;AACJ,KA1Be,CAAhB;AA2BH;AACD;AACJ;AACA;AACA;AACA;;;AACI8D,EAAAA,IAAI,GAAG;AACH,WAAO,KAAK1B,WAAZ;AACH;AACD;AACJ;AACA;;;AACIyB,EAAAA,OAAO,GAAG;AACN,WAAO,KAAKxB,cAAZ;AACH;AACD;AACJ;AACA;;;AACI8C,EAAAA,cAAc,GAAG;AACb,QAAIC,EAAJ;;AACA,WAAOjG,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,EAAE,CAACiG,EAAE,GAAG,KAAK/C,cAAX,MAA+B,IAA/B,IAAuC+C,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACrB,YAArE,CAAJ,EACI,MAAM,IAAIiB,KAAJ,CAAU,gBAAV,CAAN,CAFJ,CAGA;;AACA,cAAM;AAAE/B,UAAAA;AAAF,YAAY,MAAM,KAAK2B,iBAAL,EAAxB;AACA,YAAI3B,KAAJ,EACI,MAAMA,KAAN;AACJ,eAAO;AAAEO,UAAAA,IAAI,EAAE,KAAKnB,cAAb;AAA6ByB,UAAAA,IAAI,EAAE,KAAK1B,WAAxC;AAAqDa,UAAAA,KAAK,EAAE;AAA5D,SAAP;AACH,OARD,CASA,OAAOjD,CAAP,EAAU;AACN,eAAO;AAAEwD,UAAAA,IAAI,EAAE,IAAR;AAAcM,UAAAA,IAAI,EAAE,IAApB;AAA0Bb,UAAAA,KAAK,EAAEjD;AAAjC,SAAP;AACH;AACJ,KAbe,CAAhB;AAcH;AACD;AACJ;AACA;;;AACIqF,EAAAA,MAAM,CAACC,UAAD,EAAa;AACf,QAAIF,EAAJ;;AACA,WAAOjG,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,EAAE,CAACiG,EAAE,GAAG,KAAK/C,cAAX,MAA+B,IAA/B,IAAuC+C,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACrB,YAArE,CAAJ,EACI,MAAM,IAAIiB,KAAJ,CAAU,gBAAV,CAAN;AACJ,cAAM;AAAElB,UAAAA,IAAF;AAAQb,UAAAA;AAAR,YAAkB,MAAM,KAAKT,GAAL,CAAS+C,UAAT,CAAoB,KAAKlD,cAAL,CAAoB0B,YAAxC,EAAsDuB,UAAtD,CAA9B;AACA,YAAIrC,KAAJ,EACI,MAAMA,KAAN;AACJ,YAAI,CAACa,IAAL,EACI,MAAMkB,KAAK,CAAC,oBAAD,CAAX;AACJ,cAAMnB,OAAO,GAAG3B,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKE,cAAvB,CAAd,EAAsD;AAAEyB,UAAAA;AAAF,SAAtD,CAAhB;;AACA,aAAKE,YAAL,CAAkBH,OAAlB;;AACA,aAAKI,qBAAL,CAA2B,cAA3B;;AACA,eAAO;AAAET,UAAAA,IAAI,EAAEM,IAAR;AAAcA,UAAAA,IAAd;AAAoBb,UAAAA,KAAK,EAAE;AAA3B,SAAP;AACH,OAZD,CAaA,OAAOjD,CAAP,EAAU;AACN,eAAO;AAAEwD,UAAAA,IAAI,EAAE,IAAR;AAAcM,UAAAA,IAAI,EAAE,IAApB;AAA0Bb,UAAAA,KAAK,EAAEjD;AAAjC,SAAP;AACH;AACJ,KAjBe,CAAhB;AAkBH;AACD;AACJ;AACA;AACA;;;AACIwF,EAAAA,UAAU,CAACC,aAAD,EAAgB;AACtB,WAAOtG,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,CAACsG,aAAL,EAAoB;AAChB,gBAAM,IAAIT,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACD,cAAM;AAAExB,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKT,GAAL,CAASkD,kBAAT,CAA4BD,aAA5B,CAA9B;;AACA,YAAIxC,KAAJ,EAAW;AACP,iBAAO;AAAEY,YAAAA,OAAO,EAAE,IAAX;AAAiBZ,YAAAA,KAAK,EAAEA;AAAxB,WAAP;AACH;;AACD,aAAKe,YAAL,CAAkBR,IAAlB;;AACA,aAAKS,qBAAL,CAA2B,WAA3B;;AACA,eAAO;AAAEJ,UAAAA,OAAO,EAAEL,IAAX;AAAiBP,UAAAA,KAAK,EAAE;AAAxB,SAAP;AACH,OAXD,CAYA,OAAOjD,CAAP,EAAU;AACN,eAAO;AAAEiD,UAAAA,KAAK,EAAEjD,CAAT;AAAY6D,UAAAA,OAAO,EAAE;AAArB,SAAP;AACH;AACJ,KAhBe,CAAhB;AAiBH;AACD;AACJ;AACA;AACA;;;AACI8B,EAAAA,OAAO,CAAC5B,YAAD,EAAe;AAClB,SAAK1B,cAAL,GAAsBH,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKE,cAAvB,CAAd,EAAsD;AAAE0B,MAAAA,YAAF;AAAgB6B,MAAAA,UAAU,EAAE,QAA5B;AAAsC9B,MAAAA,IAAI,EAAE,KAAKA,IAAL;AAA5C,KAAtD,CAAtB;;AACA,SAAKG,qBAAL,CAA2B,iBAA3B;;AACA,WAAO,KAAK5B,cAAZ;AACH;AACD;AACJ;AACA;AACA;;;AACIU,EAAAA,iBAAiB,CAAClB,OAAD,EAAU;AACvB,WAAO1C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,CAACoB,SAAS,EAAd,EACI,MAAM,IAAIyE,KAAJ,CAAU,sBAAV,CAAN;AACJ,cAAMa,iBAAiB,GAAGrF,kBAAkB,CAAC,mBAAD,CAA5C;AACA,YAAIqF,iBAAJ,EACI,MAAM,IAAIb,KAAJ,CAAUa,iBAAV,CAAN;AACJ,cAAMC,cAAc,GAAGtF,kBAAkB,CAAC,gBAAD,CAAzC;AACA,cAAMuD,YAAY,GAAGvD,kBAAkB,CAAC,cAAD,CAAvC;AACA,YAAI,CAACuD,YAAL,EACI,MAAM,IAAIiB,KAAJ,CAAU,2BAAV,CAAN;AACJ,cAAMe,UAAU,GAAGvF,kBAAkB,CAAC,YAAD,CAArC;AACA,YAAI,CAACuF,UAAL,EACI,MAAM,IAAIf,KAAJ,CAAU,yBAAV,CAAN;AACJ,cAAMS,aAAa,GAAGjF,kBAAkB,CAAC,eAAD,CAAxC;AACA,YAAI,CAACiF,aAAL,EACI,MAAM,IAAIT,KAAJ,CAAU,4BAAV,CAAN;AACJ,cAAMY,UAAU,GAAGpF,kBAAkB,CAAC,YAAD,CAArC;AACA,YAAI,CAACoF,UAAL,EACI,MAAM,IAAIZ,KAAJ,CAAU,yBAAV,CAAN;AACJ,cAAMgB,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAhB;AACA,cAAMC,UAAU,GAAGL,OAAO,GAAGM,QAAQ,CAACP,UAAD,CAArC;AACA,cAAM;AAAEjC,UAAAA,IAAF;AAAQb,UAAAA;AAAR,YAAkB,MAAM,KAAKT,GAAL,CAAS+D,OAAT,CAAiBxC,YAAjB,CAA9B;AACA,YAAId,KAAJ,EACI,MAAMA,KAAN;AACJ,cAAMY,OAAO,GAAG;AACZiC,UAAAA,cADY;AAEZ/B,UAAAA,YAFY;AAGZgC,UAAAA,UAAU,EAAEO,QAAQ,CAACP,UAAD,CAHR;AAIZM,UAAAA,UAJY;AAKZZ,UAAAA,aALY;AAMZG,UAAAA,UANY;AAOZ9B,UAAAA,IAAI,EAAEA;AAPM,SAAhB;;AASA,YAAIjC,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACmB,YAA9D,EAA4E;AACxE,eAAKgB,YAAL,CAAkBH,OAAlB;;AACA,gBAAM2C,YAAY,GAAGhG,kBAAkB,CAAC,MAAD,CAAvC;;AACA,eAAKyD,qBAAL,CAA2B,WAA3B;;AACA,cAAIuC,YAAY,KAAK,UAArB,EAAiC;AAC7B,iBAAKvC,qBAAL,CAA2B,mBAA3B;AACH;AACJ,SAxCD,CAyCA;;;AACAwC,QAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,GAAuB,EAAvB;AACA,eAAO;AAAEnD,UAAAA,IAAI,EAAEK,OAAR;AAAiBZ,UAAAA,KAAK,EAAE;AAAxB,SAAP;AACH,OA5CD,CA6CA,OAAOjD,CAAP,EAAU;AACN,eAAO;AAAEwD,UAAAA,IAAI,EAAE,IAAR;AAAcP,UAAAA,KAAK,EAAEjD;AAArB,SAAP;AACH;AACJ,KAjDe,CAAhB;AAkDH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACI4G,EAAAA,OAAO,GAAG;AACN,QAAIxB,EAAJ;;AACA,WAAOjG,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,YAAM0H,WAAW,GAAG,CAACzB,EAAE,GAAG,KAAK/C,cAAX,MAA+B,IAA/B,IAAuC+C,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACrB,YAAvF;;AACA,WAAKR,cAAL;;AACA,WAAKU,qBAAL,CAA2B,YAA3B;;AACA,UAAI4C,WAAJ,EAAiB;AACb,cAAM;AAAE5D,UAAAA;AAAF,YAAY,MAAM,KAAKT,GAAL,CAASoE,OAAT,CAAiBC,WAAjB,CAAxB;AACA,YAAI5D,KAAJ,EACI,OAAO;AAAEA,UAAAA;AAAF,SAAP;AACP;;AACD,aAAO;AAAEA,QAAAA,KAAK,EAAE;AAAT,OAAP;AACH,KAVe,CAAhB;AAWH;AACD;AACJ;AACA;AACA;;;AACI6D,EAAAA,iBAAiB,CAACC,QAAD,EAAW;AACxB,QAAI;AACA,YAAM7C,EAAE,GAAGzD,IAAI,EAAf;AACA,YAAMuG,YAAY,GAAG;AACjB9C,QAAAA,EADiB;AAEjB6C,QAAAA,QAFiB;AAGjBE,QAAAA,WAAW,EAAE,MAAM;AACf,eAAKnF,mBAAL,CAAyBoF,MAAzB,CAAgChD,EAAhC;AACH;AALgB,OAArB;AAOA,WAAKpC,mBAAL,CAAyBqF,GAAzB,CAA6BjD,EAA7B,EAAiC8C,YAAjC;AACA,aAAO;AAAExD,QAAAA,IAAI,EAAEwD,YAAR;AAAsB/D,QAAAA,KAAK,EAAE;AAA7B,OAAP;AACH,KAXD,CAYA,OAAOjD,CAAP,EAAU;AACN,aAAO;AAAEwD,QAAAA,IAAI,EAAE,IAAR;AAAcP,QAAAA,KAAK,EAAEjD;AAArB,OAAP;AACH;AACJ;;AACDyE,EAAAA,kBAAkB,CAACrB,KAAD,EAAQC,QAAR,EAAkBxB,OAAO,GAAG,EAA5B,EAAgC;AAC9C,QAAIuD,EAAJ,EAAQgC,EAAR;;AACA,WAAOjI,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,cAAM;AAAEqE,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKT,GAAL,CAAS6E,eAAT,CAAyBjE,KAAzB,EAAgCC,QAAhC,EAA0C;AACpEO,UAAAA,UAAU,EAAE/B,OAAO,CAAC+B;AADgD,SAA1C,CAA9B;AAGA,YAAIX,KAAK,IAAI,CAACO,IAAd,EACI,OAAO;AAAEA,UAAAA,IAAI,EAAE,IAAR;AAAcM,UAAAA,IAAI,EAAE,IAApB;AAA0BD,UAAAA,OAAO,EAAE,IAAnC;AAAyCZ,UAAAA;AAAzC,SAAP;;AACJ,YAAI,CAAC,CAACmC,EAAE,GAAG5B,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACM,IAAvD,MAAiE,IAAjE,IAAyEsB,EAAE,KAAK,KAAK,CAArF,GAAyF,KAAK,CAA9F,GAAkGA,EAAE,CAACkC,YAAtG,MAAwH,CAACF,EAAE,GAAG5D,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACM,IAAvD,MAAiE,IAAjE,IAAyEsD,EAAE,KAAK,KAAK,CAArF,GAAyF,KAAK,CAA9F,GAAkGA,EAAE,CAACG,kBAA7N,CAAJ,EAAsP;AAClP,eAAKvD,YAAL,CAAkBR,IAAlB;;AACA,eAAKS,qBAAL,CAA2B,WAA3B;AACH;;AACD,eAAO;AAAET,UAAAA,IAAF;AAAQM,UAAAA,IAAI,EAAEN,IAAI,CAACM,IAAnB;AAAyBD,UAAAA,OAAO,EAAEL,IAAlC;AAAwCP,UAAAA,KAAK,EAAE;AAA/C,SAAP;AACH,OAXD,CAYA,OAAOjD,CAAP,EAAU;AACN,eAAO;AAAEwD,UAAAA,IAAI,EAAE,IAAR;AAAcM,UAAAA,IAAI,EAAE,IAApB;AAA0BD,UAAAA,OAAO,EAAE,IAAnC;AAAyCZ,UAAAA,KAAK,EAAEjD;AAAhD,SAAP;AACH;AACJ,KAhBe,CAAhB;AAiBH;;AACD2E,EAAAA,kBAAkB,CAACrB,KAAD,EAAQD,QAAR,EAAkB;AAChC,QAAI+B,EAAJ;;AACA,WAAOjG,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,cAAM;AAAEqE,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKT,GAAL,CAASgF,eAAT,CAAyBlE,KAAzB,EAAgCD,QAAhC,CAA9B;AACA,YAAIJ,KAAK,IAAI,CAACO,IAAd,EACI,OAAO;AAAEA,UAAAA,IAAI,EAAE,IAAR;AAAcM,UAAAA,IAAI,EAAE,IAApB;AAA0BD,UAAAA,OAAO,EAAE,IAAnC;AAAyCZ,UAAAA;AAAzC,SAAP;;AACJ,YAAI,CAACmC,EAAE,GAAG5B,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACM,IAAvD,MAAiE,IAAjE,IAAyEsB,EAAE,KAAK,KAAK,CAArF,GAAyF,KAAK,CAA9F,GAAkGA,EAAE,CAACqC,kBAAzG,EAA6H;AACzH,eAAKzD,YAAL,CAAkBR,IAAlB;;AACA,eAAKS,qBAAL,CAA2B,WAA3B;AACH;;AACD,eAAO;AAAET,UAAAA,IAAF;AAAQM,UAAAA,IAAI,EAAEN,IAAI,CAACM,IAAnB;AAAyBD,UAAAA,OAAO,EAAEL,IAAlC;AAAwCP,UAAAA,KAAK,EAAE;AAA/C,SAAP;AACH,OATD,CAUA,OAAOjD,CAAP,EAAU;AACN,eAAO;AAAEwD,UAAAA,IAAI,EAAE,IAAR;AAAcM,UAAAA,IAAI,EAAE,IAApB;AAA0BD,UAAAA,OAAO,EAAE,IAAnC;AAAyCZ,UAAAA,KAAK,EAAEjD;AAAhD,SAAP;AACH;AACJ,KAde,CAAhB;AAeH;;AACD6E,EAAAA,qBAAqB,CAACR,QAAD,EAAWxC,OAAO,GAAG,EAArB,EAAyB;AAC1C,UAAMR,GAAG,GAAG,KAAKmB,GAAL,CAASkF,iBAAT,CAA2BrD,QAA3B,EAAqC;AAC7CT,MAAAA,UAAU,EAAE/B,OAAO,CAAC+B,UADyB;AAE7CkB,MAAAA,MAAM,EAAEjD,OAAO,CAACiD;AAF6B,KAArC,CAAZ;;AAIA,QAAI;AACA;AACA,UAAIvE,SAAS,EAAb,EAAiB;AACbkG,QAAAA,MAAM,CAACC,QAAP,CAAgBiB,IAAhB,GAAuBtG,GAAvB;AACH;;AACD,aAAO;AAAEgD,QAAAA,QAAF;AAAYhD,QAAAA,GAAZ;AAAiBmC,QAAAA,IAAI,EAAE,IAAvB;AAA6BK,QAAAA,OAAO,EAAE,IAAtC;AAA4CC,QAAAA,IAAI,EAAE,IAAlD;AAAwDb,QAAAA,KAAK,EAAE;AAA/D,OAAP;AACH,KAND,CAOA,OAAOjD,CAAP,EAAU;AACN;AACA,UAAIqB,GAAJ,EACI,OAAO;AAAEgD,QAAAA,QAAF;AAAYhD,QAAAA,GAAZ;AAAiBmC,QAAAA,IAAI,EAAE,IAAvB;AAA6BK,QAAAA,OAAO,EAAE,IAAtC;AAA4CC,QAAAA,IAAI,EAAE,IAAlD;AAAwDb,QAAAA,KAAK,EAAE;AAA/D,OAAP;AACJ,aAAO;AAAEO,QAAAA,IAAI,EAAE,IAAR;AAAcM,QAAAA,IAAI,EAAE,IAApB;AAA0BD,QAAAA,OAAO,EAAE,IAAnC;AAAyCZ,QAAAA,KAAK,EAAEjD;AAAhD,OAAP;AACH;AACJ;;AACD+E,EAAAA,0BAA0B,CAAC;AAAE6C,IAAAA,QAAF;AAAYC,IAAAA,KAAZ;AAAmBC,IAAAA,SAAnB;AAA8BC,IAAAA,MAA9B;AAAsC1D,IAAAA;AAAtC,GAAD,EAAoD;AAC1E,WAAOlF,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAIyI,QAAQ,IAAIC,KAAZ,KAAuBC,SAAS,IAAIC,MAAd,IAAyB1D,QAA/C,CAAJ,EAA8D;AAC1D,YAAI;AACA,gBAAM;AAAEb,YAAAA,IAAF;AAAQP,YAAAA;AAAR,cAAkB,MAAM,KAAKT,GAAL,CAASwF,uBAAT,CAAiC;AAC3DJ,YAAAA,QAD2D;AAE3DC,YAAAA,KAF2D;AAG3DC,YAAAA,SAH2D;AAI3DC,YAAAA,MAJ2D;AAK3D1D,YAAAA;AAL2D,WAAjC,CAA9B;AAOA,cAAIpB,KAAK,IAAI,CAACO,IAAd,EACI,OAAO;AAAEM,YAAAA,IAAI,EAAE,IAAR;AAAcD,YAAAA,OAAO,EAAE,IAAvB;AAA6BZ,YAAAA;AAA7B,WAAP;;AACJ,eAAKe,YAAL,CAAkBR,IAAlB;;AACA,eAAKS,qBAAL,CAA2B,WAA3B;;AACA,iBAAO;AAAEH,YAAAA,IAAI,EAAEN,IAAI,CAACM,IAAb;AAAmBD,YAAAA,OAAO,EAAEL,IAA5B;AAAkCP,YAAAA,KAAK,EAAE;AAAzC,WAAP;AACH,SAbD,CAcA,OAAOjD,CAAP,EAAU;AACN,iBAAO;AAAE8D,YAAAA,IAAI,EAAE,IAAR;AAAcD,YAAAA,OAAO,EAAE,IAAvB;AAA6BZ,YAAAA,KAAK,EAAEjD;AAApC,WAAP;AACH;AACJ;;AACD,YAAM,IAAIgF,KAAJ,CAAW,0EAAX,CAAN;AACH,KArBe,CAAhB;AAsBH;AACD;AACJ;AACA;AACA;;;AACIrC,EAAAA,eAAe,GAAG;AACd,QAAI;AACA,YAAMa,IAAI,GAAG5C,oBAAoB,CAAC,KAAK0B,YAAN,EAAoBtB,WAApB,CAAjC;AACA,UAAI,CAACwC,IAAL,EACI,OAAO,IAAP;AACJ,YAAM;AAAEnB,QAAAA,cAAF;AAAkB4F,QAAAA;AAAlB,UAAgCzE,IAAtC;AACA,YAAMwC,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAhB;;AACA,UAAI6B,SAAS,IAAIjC,OAAO,GAAG/E,aAAvB,KAAyCoB,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,cAAc,CAACyB,IAAxH,CAAJ,EAAmI;AAC/H,aAAKE,YAAL,CAAkB3B,cAAlB;;AACA,aAAK4B,qBAAL,CAA2B,WAA3B;AACH;AACJ,KAVD,CAWA,OAAOhB,KAAP,EAAc;AACVC,MAAAA,OAAO,CAACgF,GAAR,CAAY,OAAZ,EAAqBjF,KAArB;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIL,EAAAA,kBAAkB,GAAG;AACjB,WAAOzD,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,cAAMqE,IAAI,GAAG,MAAM3C,YAAY,CAAC,KAAKyB,YAAN,EAAoBtB,WAApB,CAA/B;AACA,YAAI,CAACwC,IAAL,EACI,OAAO,IAAP;AACJ,cAAM;AAAEnB,UAAAA,cAAF;AAAkB4F,UAAAA;AAAlB,YAAgCzE,IAAtC;AACA,cAAMwC,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAhB;;AACA,YAAI6B,SAAS,GAAGjC,OAAO,GAAG/E,aAA1B,EAAyC;AACrC,cAAI,KAAKK,gBAAL,IAAyBe,cAAc,CAACoD,aAA5C,EAA2D;AACvD,iBAAKzD,cAAL;AACA,kBAAM;AAAEiB,cAAAA;AAAF,gBAAY,MAAM,KAAK2B,iBAAL,CAAuBvC,cAAc,CAACoD,aAAtC,CAAxB;;AACA,gBAAIxC,KAAJ,EAAW;AACPC,cAAAA,OAAO,CAACgF,GAAR,CAAYjF,KAAK,CAACkF,OAAlB;;AACA,kBAAIlF,KAAK,CAACkF,OAAN,KAAkBjH,eAAe,CAACkH,aAAlC,IACA,KAAKpG,cAAL,GAAsBd,eAAe,CAACmH,WAD1C,EACuD;AACnD,oBAAI,KAAKC,iBAAT,EACIC,YAAY,CAAC,KAAKD,iBAAN,CAAZ;AACJ,qBAAKA,iBAAL,GAAyBE,UAAU,CAAC,MAAM,KAAK5F,kBAAL,EAAP,EAAkCqD,IAAI,CAACwC,GAAL,CAASvH,eAAe,CAACwH,cAAzB,EAAyC,KAAK1G,cAA9C,IAAgE,GAAlG,CAAsG;AAAtG,iBAAnC;AAEA;AACH;;AACD,oBAAM,KAAKuB,cAAL,EAAN;AACH;;AACD,iBAAKvB,cAAL,GAAsB,CAAtB;AACH,WAhBD,MAiBK;AACD,iBAAKuB,cAAL;AACH;AACJ,SArBD,MAsBK,IAAI,CAAClB,cAAL,EAAqB;AACtBa,UAAAA,OAAO,CAACgF,GAAR,CAAY,kCAAZ;;AACA,eAAK3E,cAAL;AACH,SAHI,MAIA;AACD;AACA;AACA,eAAKS,YAAL,CAAkB3B,cAAlB;;AACA,eAAK4B,qBAAL,CAA2B,WAA3B;AACH;AACJ,OAtCD,CAuCA,OAAO0E,GAAP,EAAY;AACRzF,QAAAA,OAAO,CAACD,KAAR,CAAc0F,GAAd;AACA,eAAO,IAAP;AACH;AACJ,KA5Ce,CAAhB;AA6CH;;AACD/D,EAAAA,iBAAiB,CAACa,aAAD,EAAgB;AAC7B,QAAIL,EAAJ;;AACA,QAAIK,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAAEA,MAAAA,aAAa,GAAG,CAACL,EAAE,GAAG,KAAK/C,cAAX,MAA+B,IAA/B,IAAuC+C,EAAE,KAAK,KAAK,CAAnD,GAAuD,KAAK,CAA5D,GAAgEA,EAAE,CAACK,aAAnF;AAAmG;;AACnI,WAAOtG,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,UAAI;AACA,YAAI,CAACsG,aAAL,EAAoB;AAChB,gBAAM,IAAIT,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACD,cAAM;AAAExB,UAAAA,IAAF;AAAQP,UAAAA;AAAR,YAAkB,MAAM,KAAKT,GAAL,CAASkD,kBAAT,CAA4BD,aAA5B,CAA9B;AACA,YAAIxC,KAAJ,EACI,MAAMA,KAAN;AACJ,YAAI,CAACO,IAAL,EACI,MAAMwB,KAAK,CAAC,uBAAD,CAAX;;AACJ,aAAKhB,YAAL,CAAkBR,IAAlB;;AACA,aAAKS,qBAAL,CAA2B,iBAA3B;;AACA,aAAKA,qBAAL,CAA2B,WAA3B;;AACA,eAAO;AAAET,UAAAA,IAAF;AAAQP,UAAAA,KAAK,EAAE;AAAf,SAAP;AACH,OAbD,CAcA,OAAOjD,CAAP,EAAU;AACN,eAAO;AAAEwD,UAAAA,IAAI,EAAE,IAAR;AAAcP,UAAAA,KAAK,EAAEjD;AAArB,SAAP;AACH;AACJ,KAlBe,CAAhB;AAmBH;;AACDiE,EAAAA,qBAAqB,CAAC2E,KAAD,EAAQ;AACzB,SAAK9G,mBAAL,CAAyB+G,OAAzB,CAAkCC,CAAD,IAAOA,CAAC,CAAC/B,QAAF,CAAW6B,KAAX,EAAkB,KAAKvG,cAAvB,CAAxC;AACH;AACD;AACJ;AACA;AACA;;;AACI2B,EAAAA,YAAY,CAACH,OAAD,EAAU;AAClB,SAAKxB,cAAL,GAAsBwB,OAAtB;AACA,SAAKzB,WAAL,GAAmByB,OAAO,CAACC,IAA3B;AACA,UAAMmE,SAAS,GAAGpE,OAAO,CAACwC,UAA1B;;AACA,QAAI4B,SAAJ,EAAe;AACX,YAAMjC,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAhB;AACA,YAAM2C,SAAS,GAAGd,SAAS,GAAGjC,OAA9B;AACA,YAAMgD,4BAA4B,GAAGD,SAAS,GAAG9H,aAAZ,GAA4BA,aAA5B,GAA4C,GAAjF;;AACA,WAAKgI,sBAAL,CAA4B,CAACF,SAAS,GAAGC,4BAAb,IAA6C,IAAzE;AACH,KATiB,CAUlB;AACA;;;AACA,QAAI,KAAKzH,cAAL,IAAuBsC,OAAO,CAACwC,UAAnC,EAA+C;AAC3C,WAAK6C,eAAL,CAAqB,KAAK7G,cAA1B;AACH;AACJ;;AACD6G,EAAAA,eAAe,CAAC7G,cAAD,EAAiB;AAC5B,UAAMmB,IAAI,GAAG;AAAEnB,MAAAA,cAAF;AAAkB4F,MAAAA,SAAS,EAAE5F,cAAc,CAACgE;AAA5C,KAAb;AACA3F,IAAAA,YAAY,CAAC,KAAK4B,YAAN,EAAoBtB,WAApB,EAAiCwC,IAAjC,CAAZ;AACH;;AACDD,EAAAA,cAAc,GAAG;AACb,WAAOpE,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AAChD,WAAKkD,cAAL,GAAsB,IAAtB;AACA,WAAKD,WAAL,GAAmB,IAAnB;AACA,UAAI,KAAKkG,iBAAT,EACIC,YAAY,CAAC,KAAKD,iBAAN,CAAZ;AACJ3H,MAAAA,eAAe,CAAC,KAAK2B,YAAN,EAAoBtB,WAApB,CAAf;AACH,KANe,CAAhB;AAOH;AACD;AACJ;AACA;AACA;;;AACIiI,EAAAA,sBAAsB,CAACxJ,KAAD,EAAQ;AAC1B,QAAI,KAAK6I,iBAAT,EACIC,YAAY,CAAC,KAAKD,iBAAN,CAAZ;AACJ,QAAI7I,KAAK,IAAI,CAAT,IAAc,CAAC,KAAK6B,gBAAxB,EACI;AACJ,SAAKgH,iBAAL,GAAyBE,UAAU,CAAC,MAAMrJ,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,EAAuB,aAAa;AACnF,WAAK6C,cAAL;AACA,YAAM;AAAEiB,QAAAA;AAAF,UAAY,MAAM,KAAK2B,iBAAL,EAAxB;AACA,UAAI,CAAC3B,KAAL,EACI,KAAKjB,cAAL,GAAsB,CAAtB;AACJ,UAAI,CAACiB,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACkF,OAArD,MAAkEjH,eAAe,CAACkH,aAAlF,IACA,KAAKpG,cAAL,GAAsBd,eAAe,CAACmH,WAD1C,EAEI,KAAKY,sBAAL,CAA4BhD,IAAI,CAACwC,GAAL,CAASvH,eAAe,CAACwH,cAAzB,EAAyC,KAAK1G,cAA9C,IAAgE,GAA5F,EAP+E,CAOmB;AACzG,KARkD,CAAhB,EAQ/BvC,KAR+B,CAAnC;AASA,QAAI,OAAO,KAAK6I,iBAAL,CAAuBa,KAA9B,KAAwC,UAA5C,EACI,KAAKb,iBAAL,CAAuBa,KAAvB;AACP;AACD;AACJ;AACA;;;AACItG,EAAAA,wBAAwB,GAAG;AACvB,QAAI,CAAC,KAAKpB,QAAN,IAAkB,CAAClB,SAAS,EAA5B,IAAkC,EAAEkG,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAAC2C,gBAAzD,CAAtC,EAAkH;AAC9G,aAAO,KAAP;AACH;;AACD,QAAI;AACA3C,MAAAA,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAAC2C,gBAAP,CAAwB,SAAxB,EAAoCpJ,CAAD,IAAO;AACtF,YAAIoF,EAAJ;;AACA,YAAIpF,CAAC,CAACqJ,GAAF,KAAUrI,WAAd,EAA2B;AACvB,gBAAMsI,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWC,MAAM,CAACzJ,CAAC,CAAC0J,QAAH,CAAjB,CAAnB;;AACA,cAAI,CAACtE,EAAE,GAAGkE,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACjH,cAAzE,MAA6F,IAA7F,IAAqG+C,EAAE,KAAK,KAAK,CAAjH,GAAqH,KAAK,CAA1H,GAA8HA,EAAE,CAACrB,YAArI,EAAmJ;AAC/I,iBAAKC,YAAL,CAAkBsF,UAAU,CAACjH,cAA7B;;AACA,iBAAK4B,qBAAL,CAA2B,WAA3B;AACH,WAHD,MAIK;AACD,iBAAKV,cAAL;;AACA,iBAAKU,qBAAL,CAA2B,YAA3B;AACH;AACJ;AACJ,OAb+C,CAAhD;AAcH,KAfD,CAgBA,OAAOhB,KAAP,EAAc;AACVC,MAAAA,OAAO,CAACD,KAAR,CAAc,0BAAd,EAA0CA,KAA1C;AACH;AACJ;;AACDH,EAAAA,uBAAuB,GAAG;AACtB,QAAI,CAAC,KAAKrB,QAAN,IAAkB,CAAClB,SAAS,EAA5B,IAAkC,EAAEkG,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAAC2C,gBAAzD,CAAtC,EAAkH;AAC9G,aAAO,KAAP;AACH;;AACD,QAAI;AACA3C,MAAAA,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAAC2C,gBAAP,CAAwB,kBAAxB,EAA4C,MAAM;AAC9F,YAAIO,QAAQ,CAACC,eAAT,KAA6B,SAAjC,EAA4C;AACxC,eAAKhH,kBAAL;AACH;AACJ,OAJ+C,CAAhD;AAKH,KAND,CAOA,OAAOK,KAAP,EAAc;AACVC,MAAAA,OAAO,CAACD,KAAR,CAAc,yBAAd,EAAyCA,KAAzC;AACH;AACJ;;AA5oB6B","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid, setItemAsync, removeItemAsync, getItemSynchronously, getItemAsync, } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY, EXPIRY_MARGIN, NETWORK_FAILURE, } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: GOTRUE_URL,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: DEFAULT_HEADERS,\n};\nexport default class GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param options.url The URL of the GoTrue server.\n     * @param options.headers Any additional headers to send to the GoTrue server.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.cookieOptions\n     * @param options.fetch A custom fetch implementation.\n     */\n    constructor(options) {\n        this.stateChangeEmitters = new Map();\n        this.networkRetries = 0;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.currentUser = null;\n        this.currentSession = null;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.multiTab = settings.multiTab;\n        this.localStorage = settings.localStorage || globalThis.localStorage;\n        this.api = new GoTrueApi({\n            url: settings.url,\n            headers: settings.headers,\n            cookieOptions: settings.cookieOptions,\n            fetch: settings.fetch,\n        });\n        this._recoverSession();\n        this._recoverAndRefresh();\n        this._listenForMultiTabEvents();\n        this._handleVisibilityChange();\n        if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n            // Handle the OAuth redirect\n            this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n                if (error) {\n                    console.error('Error getting session from URL.', error);\n                }\n            });\n        }\n    }\n    /**\n     * Creates a new user.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param password The user's password.\n     * @param phone The user's phone number.\n     * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n     * @param data Optional user metadata.\n     */\n    signUp({ email, password, phone }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = phone && password\n                    ? yield this.api.signUpWithPhone(phone, password, {\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    })\n                    : yield this.api.signUpWithEmail(email, password, {\n                        redirectTo: options.redirectTo,\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    });\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on sign up.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n    signIn({ email, phone, password, refreshToken, provider, oidc }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                if (email && !password) {\n                    const { error } = yield this.api.sendMagicLinkEmail(email, {\n                        redirectTo: options.redirectTo,\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (email && password) {\n                    return this._handleEmailSignIn(email, password, {\n                        redirectTo: options.redirectTo,\n                    });\n                }\n                if (phone && !password) {\n                    const { error } = yield this.api.sendMobileOTP(phone, {\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (phone && password) {\n                    return this._handlePhoneSignIn(phone, password);\n                }\n                if (refreshToken) {\n                    // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n                    const { error } = yield this._callRefreshToken(refreshToken);\n                    if (error)\n                        throw error;\n                    return {\n                        user: this.currentUser,\n                        session: this.currentSession,\n                        error: null,\n                    };\n                }\n                if (provider) {\n                    return this._handleProviderSignIn(provider, {\n                        redirectTo: options.redirectTo,\n                        scopes: options.scopes,\n                    });\n                }\n                if (oidc) {\n                    return this._handleOpenIDConnectSignIn(oidc);\n                }\n                throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param type The user's verification type.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyOTP(params, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = yield this.api.verifyOTP(params, options);\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on token verification.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */\n    user() {\n        return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */\n    session() {\n        return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */\n    refreshSession() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                // currentSession and currentUser will be updated to latest on _callRefreshToken\n                const { error } = yield this._callRefreshToken();\n                if (error)\n                    throw error;\n                return { data: this.currentSession, user: this.currentUser, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n    update(attributes) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                const { user, error } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n                if (error)\n                    throw error;\n                if (!user)\n                    throw Error('Invalid user data.');\n                const session = Object.assign(Object.assign({}, this.currentSession), { user });\n                this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED');\n                return { data: user, user, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sets the session data from refresh_token and returns current Session and Error\n     * @param refresh_token a JWT token\n     */\n    setSession(refresh_token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error) {\n                    return { session: null, error: error };\n                }\n                this._saveSession(data);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { session: data, error: null };\n            }\n            catch (e) {\n                return { error: e, session: null };\n            }\n        });\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */\n    setAuth(access_token) {\n        this.currentSession = Object.assign(Object.assign({}, this.currentSession), { access_token, token_type: 'bearer', user: this.user() });\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n        return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */\n    getSessionFromUrl(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!isBrowser())\n                    throw new Error('No browser detected.');\n                const error_description = getParameterByName('error_description');\n                if (error_description)\n                    throw new Error(error_description);\n                const provider_token = getParameterByName('provider_token');\n                const access_token = getParameterByName('access_token');\n                if (!access_token)\n                    throw new Error('No access_token detected.');\n                const expires_in = getParameterByName('expires_in');\n                if (!expires_in)\n                    throw new Error('No expires_in detected.');\n                const refresh_token = getParameterByName('refresh_token');\n                if (!refresh_token)\n                    throw new Error('No refresh_token detected.');\n                const token_type = getParameterByName('token_type');\n                if (!token_type)\n                    throw new Error('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { user, error } = yield this.api.getUser(access_token);\n                if (error)\n                    throw error;\n                const session = {\n                    provider_token,\n                    access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at,\n                    refresh_token,\n                    token_type,\n                    user: user,\n                };\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                    this._saveSession(session);\n                    const recoveryMode = getParameterByName('type');\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    if (recoveryMode === 'recovery') {\n                        this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                    }\n                }\n                // Remove tokens from URL\n                window.location.hash = '';\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n     */\n    signOut() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n            this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT');\n            if (accessToken) {\n                const { error } = yield this.api.signOut(accessToken);\n                if (error)\n                    return { error };\n            }\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */\n    onAuthStateChange(callback) {\n        try {\n            const id = uuid();\n            const subscription = {\n                id,\n                callback,\n                unsubscribe: () => {\n                    this.stateChangeEmitters.delete(id);\n                },\n            };\n            this.stateChangeEmitters.set(id, subscription);\n            return { data: subscription, error: null };\n        }\n        catch (e) {\n            return { data: null, error: e };\n        }\n    }\n    _handleEmailSignIn(email, password, options = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithEmail(email, password, {\n                    redirectTo: options.redirectTo,\n                });\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handlePhoneSignIn(phone, password) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithPhone(phone, password);\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handleProviderSignIn(provider, options = {}) {\n        const url = this.api.getUrlForProvider(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n        });\n        try {\n            // try to open on the browser\n            if (isBrowser()) {\n                window.location.href = url;\n            }\n            return { provider, url, data: null, session: null, user: null, error: null };\n        }\n        catch (e) {\n            // fallback to returning the URL\n            if (url)\n                return { provider, url, data: null, session: null, user: null, error: null };\n            return { data: null, user: null, session: null, error: e };\n        }\n    }\n    _handleOpenIDConnectSignIn({ id_token, nonce, client_id, issuer, provider, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (id_token && nonce && ((client_id && issuer) || provider)) {\n                try {\n                    const { data, error } = yield this.api.signInWithOpenIDConnect({\n                        id_token,\n                        nonce,\n                        client_id,\n                        issuer,\n                        provider,\n                    });\n                    if (error || !data)\n                        return { user: null, session: null, error };\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    return { user: data.user, session: data, error: null };\n                }\n                catch (e) {\n                    return { user: null, session: null, error: e };\n                }\n            }\n            throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n        });\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */\n    _recoverSession() {\n        try {\n            const data = getItemSynchronously(this.localStorage, STORAGE_KEY);\n            if (!data)\n                return null;\n            const { currentSession, expiresAt } = data;\n            const timeNow = Math.round(Date.now() / 1000);\n            if (expiresAt >= timeNow + EXPIRY_MARGIN && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n                this._saveSession(currentSession);\n                this._notifyAllSubscribers('SIGNED_IN');\n            }\n        }\n        catch (error) {\n            console.log('error', error);\n        }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    _recoverAndRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield getItemAsync(this.localStorage, STORAGE_KEY);\n                if (!data)\n                    return null;\n                const { currentSession, expiresAt } = data;\n                const timeNow = Math.round(Date.now() / 1000);\n                if (expiresAt < timeNow + EXPIRY_MARGIN) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        this.networkRetries++;\n                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            if (error.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n                                this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                                if (this.refreshTokenTimer)\n                                    clearTimeout(this.refreshTokenTimer);\n                                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                                );\n                                return;\n                            }\n                            yield this._removeSession();\n                        }\n                        this.networkRetries = 0;\n                    }\n                    else {\n                        this._removeSession();\n                    }\n                }\n                else if (!currentSession) {\n                    console.log('Current session is missing data.');\n                    this._removeSession();\n                }\n                else {\n                    // should be handled on _recoverSession method already\n                    // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                    this._saveSession(currentSession);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n            }\n            catch (err) {\n                console.error(err);\n                return null;\n            }\n        });\n    }\n    _callRefreshToken(refresh_token) {\n        var _a;\n        if (refresh_token === void 0) { refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token; }\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error)\n                    throw error;\n                if (!data)\n                    throw Error('Invalid session data.');\n                this._saveSession(data);\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    _notifyAllSubscribers(event) {\n        this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    _saveSession(session) {\n        this.currentSession = session;\n        this.currentUser = session.user;\n        const expiresAt = session.expires_at;\n        if (expiresAt) {\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = expiresAt - timeNow;\n            const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n            this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n        }\n        // Do we need any extra check before persist session\n        // access_token or user ?\n        if (this.persistSession && session.expires_at) {\n            this._persistSession(this.currentSession);\n        }\n    }\n    _persistSession(currentSession) {\n        const data = { currentSession, expiresAt: currentSession.expires_at };\n        setItemAsync(this.localStorage, STORAGE_KEY, data);\n    }\n    _removeSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.currentSession = null;\n            this.currentUser = null;\n            if (this.refreshTokenTimer)\n                clearTimeout(this.refreshTokenTimer);\n            removeItemAsync(this.localStorage, STORAGE_KEY);\n        });\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */\n    _startAutoRefreshToken(value) {\n        if (this.refreshTokenTimer)\n            clearTimeout(this.refreshTokenTimer);\n        if (value <= 0 || !this.autoRefreshToken)\n            return;\n        this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            this.networkRetries++;\n            const { error } = yield this._callRefreshToken();\n            if (!error)\n                this.networkRetries = 0;\n            if ((error === null || error === void 0 ? void 0 : error.message) === NETWORK_FAILURE.ERROR_MESSAGE &&\n                this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)\n                this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n        }), value);\n        if (typeof this.refreshTokenTimer.unref === 'function')\n            this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */\n    _listenForMultiTabEvents() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('storage', (e) => {\n                var _a;\n                if (e.key === STORAGE_KEY) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                        this._saveSession(newSession.currentSession);\n                        this._notifyAllSubscribers('SIGNED_IN');\n                    }\n                    else {\n                        this._removeSession();\n                        this._notifyAllSubscribers('SIGNED_OUT');\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n        }\n    }\n    _handleVisibilityChange() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'visible') {\n                    this._recoverAndRefresh();\n                }\n            });\n        }\n        catch (error) {\n            console.error('_handleVisibilityChange', error);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}